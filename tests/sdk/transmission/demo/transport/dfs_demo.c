/*
 * Copyright (c) 2022 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file dfs_demo.c
 *
 * @brief Provides the sample code for the distributed file service.
 *
 * @since 1.0
 * @version 1.0
 */

// Device A:

#include <stdio.h>
#include "session.h"
#include "softbus_config_type.h"

const char *g_pkgNameA = "dms"; // Application bundle name of device A
const char *g_sessionNameA = "DistributedFileService"; // Session name of the distributed file service of device A
const char *g_sessionNameB = "DistributedFileService"; // Session name of the distributed file service of device B

// Network ID generated by device B after devices A and B are networked.
const char *g_networkidB = "ABCDEF00ABCDEF00ABCDEF00ABCDEF00ABCDEF00ABCDEF00ABCDEF00ABCDEF00";
const char *g_groupid = "TEST_GROUP_ID";  // Group ID
static SessionAttribute g_sessionAttr = {
    .dataType = TYPE_FILE, // Session type
};
const char *g_testData = "TranSessionTest_GetSessionKeyTestData";

// Notify that the session is set up successfully.
static int32_t OnSessionOpened(int32_t sessionId, int32_t result)
{
    printf("session opened,sesison id = %d\r\n", sessionId);
    return 0;
}

// Notify that the session is closed.
static void OnSessionClosed(int32_t sessionId)
{
    printf("session closed, session id = %d\r\n", sessionId);
}

// Notify that the byte data is received.
static void OnBytesReceived(int32_t sessionId, const void *data, unsigned int len)
{
    printf("session bytes received, session id = %d\r\n", sessionId);
}

// Notify that the message is received.
static void OnMessageReceived(int32_t sessionId, const void *data, unsigned int len)
{
    printf("session msg received, session id = %d\r\n", sessionId);
}

// Notify that the stream data is received.
static void OnStreamReceived(int32_t sessionId, const StreamData *data,
                             const StreamData *ext, const StreamFrameInfo *param)
{
    printf("session stream received, session id = %d\r\n", sessionId);
}

static ISessionListener g_sessionlistenerA = {
    .OnSessionOpened = OnSessionOpened,
    .OnSessionClosed = OnSessionClosed,
    .OnBytesReceived = OnBytesReceived,
    .OnMessageReceived = OnMessageReceived,
    .OnStreamReceived = OnStreamReceived,
};

int32_t main(void)
{
    /*
     * 1. Device A calls CreateSessionServer() to create a session service based on the application bundle name and
     * session name, and registers the callbacks for session opened, session closed, byte received, and message
     * received.
     */
    int32_t ret = CreateSessionServer(g_pkgNameA, g_sessionNameA, &g_sessionlistenerA);
    printf("create session server result = %d\n", ret);

    /*
     * 2. Device A calls OpenSession() to open a session based on the local session name, peer session name, and peer
     * network ID, and then determines the session channel based on the session type.
     * When the session is open, a callback will be invoked to notify devices A and B.
     * A session ID is returned for subsequent operations. In addition, sessionName must be DistributedFileService.
     */
    int32_t sessionId = OpenSession(g_sessionNameA, g_sessionNameB, g_networkidB, g_groupid, &g_sessionAttr);
    printf("open session result = %d\n", sessionId);
    
    /* 3. Device A calls the APIs provided by the distributed file service to perform operations. */
    char *key = (char *)g_testData;
    unsigned int len = strlen(key);
    ret = GetSessionKey(sessionId, key, len);
    printf("get session key result = %d\n", ret);
    
    int32_t handle = 1;
    ret = GetSessionHandle(sessionId, &handle);
    printf("get session handle result = %d\n", ret);
    
    ret = DisableSessionListener(sessionId);
    printf("disable session listener result = %d\n", ret);
}
